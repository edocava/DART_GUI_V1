# This file was generated by the Tkinter Designer by Parth Jadhav
# https://github.com/ParthJadhav/Tkinter-Designer

import tkinter as tk
from tkinter import Tk, Canvas, Button, StringVar
import matplotlib.pyplot
from matplotlib.figure import Figure
import GS_Funcs

import serial
from GS_Funcs import MB_CMD, MB_STATE, MB_GET_STATUS
import time
import datetime
import serial.tools.list_ports as ports

matplotlib.use('TkAgg')
import tkintermapview
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

matplotlib.pyplot.style.use('dark_background')
matplotlib.rcParams['grid.color'] = 'grey'
from bitmask import unpack_error

BGCOLOR = '#161618'

#System Variables

VERBOSE_ON = 0
RX_CNT = 0

current_state = 0.0
state = 0
err = 0
lat = 45.07916667
lon = 7.67611111
alt = 0
baro_alt = 0
check = 0.0

class Point():
    def __init__(self, tmp, height):
        self.tmp = tmp
        self.height = height

class LogSample():
    def __init__(self, state, lat, lon, baro_alt, alt, check):
        self.state = state
        self.lat = lat
        self.lon = lon
        self.baro_alt = baro_alt
        self.alt = alt
        self.check = check

def serialize(obj, file_path: str):
    with open(file_path, 'ab') as file:
        pickle.dump(obj, file)
    file.close()

def deserialize(file_path: str):
    with open(file_path, 'rb') as file:
        while True:
            try:
                obj = pickle.load(file)
                print(obj.state, obj.lat, obj.lon, obj.baro_alt, obj.alt, obj.check)
            except EOFError:
                break
    file.close()

class GUI():
    def __init__(self, root):

        global lat, lon, alt, baro_alt
        self.window = root
        self.window.geometry("1280x800+50+50")
        self.window.configure(bg=BGCOLOR)
        self.window.attributes("-topmost", False)

        self.cnt = 0
        self.points_gps = list()
        self.points_baro = list()
        self.canvas = Canvas(self.window, bg=BGCOLOR, height=720, width=720, bd=0, highlightthickness=0, relief="ridge")
        self.canvas.place(x=0, y=0)

        self.add_label_and_field("Altitudine:", f"{alt:.1f} m\n", 30, 18, self.canvas)
        self.add_label_and_field("BaroAlt:", f"{baro_alt:.1f} m\n", 60, 18, self.canvas)
        self.add_label_and_field("Latitudine:", f"{lat:.5f}째\n", 90, 18, self.canvas)
        self.add_label_and_field("Longitudine:", f"{lon:.5f}째\n", 120, 18, self.canvas)
        self.add_label_and_field("Status:", self.get_state(), 150, 18, self.canvas)
        now = datetime.datetime.now()
        formatted_time = now.strftime("%H:%M:%S.%f")[:-4]
        self.add_label_and_field("TS:", f"{formatted_time}\n", 180, 18, self.canvas)
        self.add_alt_plot(self.window, x_start=70, y_start=220)
        unpack_error(0b11111111, x_start=50, y_start=500, canvas=self.canvas)
        self.terminal = tk.Text(self.window, height=12, width=50, bg=BGCOLOR, fg="green", font=("Courier", 16))
        self.terminal.place(x=50, y=540)

        self.terminal.bind("<Return>", self.on_enter)
        self.terminal.bind("<Up>", lambda event: "break")
        self.terminal.bind("<Down>", lambda event: "break")

        self.history = list()
        self.history_idx = 0
        self.history_idx_back = 0
        self.terminal.mark_set("insert", "end")
        self.terminal.focus()
        self.terminal.yview_scroll(1, "units")

        self.waiting_for_serial_input = True
        GS_Funcs.init_Serial()
        self.showPorts()
        self.window.resizable(width=False, height=False)

        self.map_widget = tkintermapview.TkinterMapView(self.window, width=600, height=600, corner_radius=10)
        self.map_widget.set_tile_server("https://mt0.google.com/vt/lyrs=s&hl=en&x={x}&y={y}&z={z}&s=Ga", max_zoom=20)
        self.map_widget.place(x=650, y=30)
        self.map_widget.set_zoom(15)
        self.map_widget.set_position(lat, lon)
        # TODO small_marker_icon = PhotoImage(file="path_to_small_marker_icon.png")
        self.map_widget.set_marker(lat, lon, text="") #TODO !! self.map_widget.set_marker(lat, lon, text="", icon=small_marker_icon)

        self.window.resizable(False, False)
        self.window.title('Ground Station DART V1.0')
        self.window.iconbitmap("Plane.ico")

    def get_state(self):
        global state
        return str(GS_Funcs.MB_FSM.to_dict()[state]).replace("MB_", '').replace("_STATE", '')

    def update_gui(self, window, canvas):
        global lat, lon
        canvas.delete("all")
        self.add_label_and_field("Altitudine:", f"{alt} m\n", 30, 20, canvas)
        self.add_label_and_field("Latitudine:", f"{lat}째\n", 70, 20, canvas)
        self.add_label_and_field("Longitudine:", f"{lon}째\n", 110, 20, canvas)
        self.add_label_and_field("Status:", self.get_state(), 150, 20, canvas)
        self.add_alt_plot(window, x_start=50, y_start=190)
        unpack_error(0b11111111, x_start=50, y_start=500, canvas=canvas)
        self.map_widget.set_position(lat, lon)
        self.map_widget.set_marker(lat, lon, text="")


    def add_alt_plot(self, root, x_start, y_start):
        ALT_Plot = Figure(figsize=(4.2, 2.6), dpi=100)
        ALT_Plot.set_facecolor(BGCOLOR)
        ALT_Plot.suptitle('Altitude AGL (m)')
        Altitude_Plot = ALT_Plot.add_subplot()
        Altitude_Plot.grid(visible=True)
        Altitude_Plot.set_facecolor(BGCOLOR)

        for i in range(self.cnt):
            Altitude_Plot.scatter(self.points_gps[i].tmp, self.points_gps[i].height, color='red', s=15, alpha=1)
            Altitude_Plot.scatter(self.points_baro[i].tmp, self.points_baro[i].height, color='blue', s=15, alpha=1)

        plot = FigureCanvasTkAgg(figure=ALT_Plot, master=root)
        plot.draw()
        plot.get_tk_widget().place(x=x_start, y=y_start)


    def add_label_and_field(self, label, value, y_position, font_size, canvas, x_position=None):
        if x_position is None:
            canvas.create_text(
                56.0,
                y_position,
                anchor="nw",
                text=label,
                fill="#E5E1E1",
                font=("Inter", font_size * -1)
            )

            canvas.create_text(
                209.0,
                y_position,
                anchor="nw",
                text=value,
                fill="#E5E1E1",
                font=("Inter", font_size * -1)
            )
        else:
            canvas.create_text(
                x_position,
                y_position,
                anchor="nw",
                text=label,
                fill="#E5E1E1",
                font=("Inter", font_size * -1)
            )

            canvas.create_text(
                x_position + 153.0,
                y_position,
                anchor="nw",
                text=value,
                fill="#E5E1E1",
                font=("Inter", font_size * -1)
            )

    def showPorts(self):
        self.terminal.insert(tk.END, "Listing all available ports...\n")
        for [index, port] in enumerate(ports.comports()):
            self.terminal.insert(tk.END, f"{index} > {str(port).split(' ')[0]}\n")
        self.terminal.insert(tk.END, "> Select serial port: ")
        self.terminal.mark_set("insert", "end")


    def on_enter(self, event):
        opt = self.terminal.get("end-1l linestart", "end-1c").strip()
        if '> ' in opt:
            opt = opt.replace('> ', '')

        if self.waiting_for_serial_input:
            opt = opt.split(' ')[-1]
            print(opt)
            try:
                GS_Funcs.Connect_Serial(str(ports.comports()[int(opt)]).split(' ')[0])
                self.waiting_for_serial_input = False
                self.terminal.insert(tk.END, "\nSerial port connected\n")
            except ValueError:
                self.terminal.insert(tk.END, "\nSyntax Error!!")
                self.showPorts()
        else:
            self.terminal.insert(tk.END, "\n")
            if "set_state" in opt:
                if len(opt.strip().split(' ')) == 1:
                    self.terminal.insert(tk.END, "Possible states\n")
                    self.terminal.insert(tk.END, "- sleep\n")
                    self.terminal.insert(tk.END, "- wake_up\n")
                    self.terminal.insert(tk.END, "- disarm\n")
                    self.terminal.insert(tk.END, "- arm\n")
                elif len(opt.strip().split(' ')) == 2:
                    st = opt.strip().split(' ')[1]
                    if st == "sleep":
                        GS_Funcs.WriteData(MB_STATE.MB_SLEEP_REQ, 0)
                        self.read_current_state()
                    elif st == "wake_up":
                        GS_Funcs.WriteData(MB_STATE.MB_WAKEUP_REQ, 0)
                        self.read_current_state()
                    elif st == "disarm":
                        GS_Funcs.WriteData(MB_STATE.MB_DISARM_REQ, 0)
                        self.read_current_state()
                    elif st == "arm":
                        GS_Funcs.WriteData(MB_STATE.MB_ARM_REQ, 0)
                        self.read_current_state()
                    else:
                        self.terminal.insert(tk.END, "\n")
                        self.terminal.insert(tk.END, "Invalid state\n")

                else:
                    self.terminal.insert(tk.END,"Syntax error\n")
            elif "set_reset" == opt:
                GS_Funcs.WriteData(MB_CMD.MB_INIT_CMD_RESET, 0)
                self.terminal.insert(tk.END, "System resetting...\n")
                self.terminal.insert(tk.END, "Checking for new status...\n")
                GS_Funcs.set_timeout(GS_Funcs.TIMEOUT_RESET)
                GS_Funcs.WriteData(MB_GET_STATUS, 0)
                self.read_current_state()
                if check != 0:
                    if state == GS_Funcs.MB_FSM.MB_INIT_STATE:
                        self.terminal.insert(tk.END, "System reset success\n")
                    else:
                        self.terminal.insert(tk.END, "System reset failed\n")
                else:
                    self.terminal.insert(tk.END, "General Communication error\n")

                GS_Funcs.set_timeout(GS_Funcs.TIMEOUT_STD)
            elif "get_state" == opt:

                GS_Funcs.WriteData(MB_GET_STATUS, 0)
                self.read_current_state()
            elif "get_errors" == opt:

                GS_Funcs.WriteData(MB_CMD.MB_INIT_CMD_GET_ERRORS, 0)
                self.read_current_state()
            elif "set_verbosity" in opt:
                if len(opt.strip().split(' ')) == 2:
                    if opt.strip().split(' ')[1].lower() == "on":
                        VERBOSE_ON = 1
                    elif opt.strip().split(' ')[1].lower() == "off":
                        VERBOSE_ON = 0
                    else:
                        self.print_help()
                else:
                    self.print_help()
            elif "set_rx_cont" in opt:
                if len(opt.strip().split(' ')) == 2:
                    if opt.strip().split(' ')[1].lower() == "on":
                        RX_CNT = 1
                        VERBOSE_ON = 1
                        self.read_current_state()
                    elif opt.strip().split(' ')[1].lower() == "off":
                        RX_CNT = 0
                    else:
                        self.print_help()
                else:
                    self.print_help()
            else:
                self.print_help()

            self.history.append(opt)
            self.history_idx += 1
            self.history_idx_back = self.history_idx

        self.terminal.bind("<Up>", self.on_up_arrow)
        self.terminal.bind("<Down>", self.on_down_arrow)
        self.terminal.insert(tk.END, "> ")
        self.terminal.mark_set("insert", "end")
        return "break"

    def on_up_arrow(self, event):
        if self.history_idx_back > 0:
            self.history_idx_back -= 1
            self.terminal.delete("end-1l+2c", "end")
            self.terminal.insert(tk.END, f"{self.history[self.history_idx_back]}")
        self.terminal.mark_set("insert", "end")
        return "break"

    def on_down_arrow(self, event):
        if self.history_idx_back < self.history_idx:
            self.history_idx_back += 1
            self.terminal.delete("end-1l+2c", "end")
            self.terminal.insert(tk.END, f"{self.history[self.history_idx_back]}")
        self.terminal.mark_set("insert", "end")
        return "break"

    def print_help(self):
        self.terminal.insert(tk.END, "\n")
        self.terminal.insert(tk.END, "Available commands\n")
        self.terminal.insert(tk.END, "- set_verbosity (on/off)\n")
        self.terminal.insert(tk.END, "- set_state <state>\n")
        self.terminal.insert(tk.END, "- set_reset\n")
        self.terminal.insert(tk.END, "- get_state\n")
        self.terminal.insert(tk.END, "- get_errors\n")
        self.terminal.insert(tk.END, "- set_rx_cont (on/off)\n")

    def print_err(self):
        global err
        err_list = list()
        for (err_name, err_val) in GS_Funcs.MB_ERROR.items():
            if err & (0b01 << err_val):
                err_list.append(err_name.replace('BITMSK_SHIFT_', ''))
        if len(err_list) == 0:
            self.terminal.insert(tk.END, "No errors found\n")
        else:
            self.terminal.insert(tk.END, "Errors:\n", err_list)

    def read_current_state(self):
        global state, err, lat, lon, baro_alt, alt, check
        state_tmp, err_tmp, lat_tmp, lon_tmp, alt_tmp, check_tmp = GS_Funcs.ReadData()
        if lat_tmp is not None and lon_tmp is not None:
            lat = lat_tmp[0]
            lon = lon_tmp[0]
            err = err_tmp

            baro_alt = err * 3500.0 / 255.0
            alt = alt_tmp
            check = check_tmp
            state = state_tmp

            if self.cnt < 50:
                self.cnt += 1
                self.points_gps.append(Point(int(time.time()), alt))
                self.points_gps.append(Point(int(time.time()), baro_alt))
            else:
                self.points_baro.pop(0)
                self.points_gps.pop(0)
                self.points_baro.append(Point(int(time.time()), alt))
                self.points_baro.append(Point(int(time.time()), baro_alt))

            obj = LogSample(state, lat, lon, baro_alt, alt, check)
            serialize(obj, "log.pkl")

        if check == None:
            self.terminal.insert(tk.END, "Error while fetching state\n")
            return
        if VERBOSE_ON == 1:
            self.terminal.insert(tk.END, "BOARD STATUS\n")
            self.terminal.insert(tk.END, f"{datetime.datetime.now()}\n")
            self.terminal.insert(tk.END, "-" * 10)
            self.terminal.insert(tk.END, f"\nState:{GS_Funcs.MB_FSM.to_dict()[state]}\n")
            self.print_err()
            self.terminal.insert(tk.END, f"Latitude:{lat[0]} deg\n")
            self.terminal.insert(tk.END, f"Longitude:{lon[0]} deg\n")
            self.terminal.insert(tk.END, f"Altitude:{alt} m\n")
        if RX_CNT == 1:
            self.window.after(1, self.read_current_state)
        self.update_gui(self.window, self.canvas)

    def choose_serial(self):
        return GS_Funcs.choose_Serial_term(self.terminal)